#Common variables:
TEST_DIR="$(realpath ../..)"
TEST_HELPERS="${TEST_DIR}/test_helpers"

#Function to be finished.
#This function is tied at the hip to Bash.
#It will not work in ANY other shell.
declare -a arr_actual
declare -a arr_expected


#This function is only intended to called in the event
#an error occurs that will impede the effectiveness of this
#test suite. It is not to be called when running the
#test suite in the event of input failing the test in
#question.  That's because test failure is expected,
#and is not a reason to halt all operations. In that
#case, we return a non-zero error code and let execution
#continue
function die {
   [ $# -lt 2 ] && >&2 echo "die: Too few arguments" && exit 1
   [ $# -gt 2 ] && >&2 echo "die: Too many arguments" && exit 1

   local func_name=$1
   local message=$2
   >&2 echo "${func_name}:${message}"
   exit 1 
}

function __arrs_exist {
    [ ! $# -lt 1 ] && die "__arrs_exist" "Too few arguments."
    [ ! $# -gt 1 ] && die "__arrs_exist" "Too many arguments"

    [ "$(set -o posix; set | grep -i 'arr_actual')" == "" ] || \
    [ "$(set -o posix; set | grep -i 'arr_expected')" == "" ]; && \ 
    return 1
    return 0
}

function assert_correct_by_output_and_errcode {
    #Make sure arr_actual and arr_expected exist
    #and have values:

    #Fix this logic to properly use the "die" function
    ! __arrs_exist  && die \
    "assert_correct_by_output_and_errcode" \
    "One or more of \"arr_actual\" and \"arr_expected\" \
    is not set. This function requires these arrays. \
    Please create them." && \
    return 1

    local actual_size="${#arr_actual[@]}"
    local expected_size="${#arr_expected[@]}"

    #Make sure the arrays have values:
    if [ ${actual_size} -eq 0 ] ||
       [ ${expected_size} -eq 0 ]; then
       echo "One or more of \"arr_actual\" and \"arr_expected\""
       echo "does (do) not have values. Both arrays must be populated"
       echo "for this function to work. Returing now."
       return 1
    fi

    function __print_comparison {
        echo
        echo
        echo "# Expected output:"
        echo "######################################"
        echo "# Line count: ${#arr_expected[@]}"
        echo
        echo "# Values:"
        echo "######################################"
        for var in ${arr_expected[@]}; do
            echo "${var}"
        done
        echo
        echo

        echo "# Actual output:"
        echo "######################################"
        echo "# Line count: ${#arr_actual[@]}"
        echo
        echo "# Values:"
        echo "######################################"
        for var in ${arr_actual[@]}; do
            echo "${var}"
        done
        echo
        echo
    }
    
    #Check the errcode:
    local __errcode="${arr_actual[-1]}"
    if [ ${__errcode} -gt 0 ]; then
        echo "Error. Output a has non-zero error code,"
        echo "indicating a failure in the logic under test."
        echo "Errcode: ${__errcode}"
        __print_comparison
        return 1
    fi

    local __counter=0 
    #Actual output is fewer lines than expected.
    #Hence, there is obviously a problem:
    if [ ! ${actual_size} -eq ${expected_size} ]; then
         echo "Error. Actual output and expected output do"
         echo "do not have the same number of lines."
         echo "This is probably due to an error in"
         echo "the logic under test."
         echo "Hence, we fail early here."
         __print_comparison
         return 1
    fi
    
    #Check each line one at a time:
    while [ ${__counter} -lt ${actual_size}  ]; do
        if [ "${arr_actual[${__counter}]}" != "${arr_expected[${__counter}]}"  ]; then
            echo "Error. Actual output and expected output do not match."
            __print_comparison
            return 1
        fi
        __counter=$((__counter + 1))
    done
}

function assert_errcode {
    [ $# -lt 1  ] && die "assert_errcode" "Too few arguments"
    [ ${#} -gt 1  ] && die "assert_errcode" "Error. Too many arguments."

    if ! __arrs_exist;  then

    fi

    local __expected_code=$1
    #Make sure that arr_actual has output.
}


#Populate the arrays.
function populate_output_arr_with_output {
    for var in ${@}; do
        arr_output+=("${var}")
    done
}


